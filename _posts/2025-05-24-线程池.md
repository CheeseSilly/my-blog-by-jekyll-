---
title: 2025/5/24 çº¿ç¨‹æ±  BY C++
author: Sillycheese
date: 2025/5/24 12:50:22 +0800
categories:
  - Logs
---
#### 1. æ ¸å¿ƒåŠŸèƒ½ä¸è®¾è®¡ç›®æ ‡

- **ç›®çš„**ï¼šç®¡ç†ä¸€ä¸ªçº¿ç¨‹é˜Ÿåˆ—ï¼Œç”¨äºå¼‚æ­¥æ‰§è¡Œæäº¤çš„ä»»åŠ¡ï¼Œé¿å…é¢‘ç¹åˆ›å»ºå’Œé”€æ¯çº¿ç¨‹çš„å¼€é”€ã€‚
- **ä¸»è¦æ“ä½œ**ï¼š
    - åˆå§‹åŒ–æŒ‡å®šæ•°é‡çš„å·¥ä½œçº¿ç¨‹ã€‚
    - å‘ä»»åŠ¡é˜Ÿåˆ—ä¸­æ·»åŠ ä»»åŠ¡ (`enqueue`)ã€‚
    - å·¥ä½œçº¿ç¨‹ä»é˜Ÿåˆ—ä¸­å–å‡ºä»»åŠ¡å¹¶æ‰§è¡Œã€‚
    - ç­‰å¾…æ‰€æœ‰å·²æäº¤ä»»åŠ¡å®Œæˆ (`waitAllTasks`)ã€‚
    - å®‰å…¨åœ°åœæ­¢å¹¶é”€æ¯çº¿ç¨‹æ±  (`~ThreadPool`)ã€‚

---

#### 2. æ„é€ å‡½æ•° `ThreadPool(size_t numThreads)`

- **åˆå§‹åŒ–æˆå‘˜å˜é‡**ï¼š
    - `taskCount` (å·²æäº¤ä¸”æœªå®Œæˆçš„ä»»åŠ¡æ•°) åˆå§‹åŒ–ä¸º 0ã€‚
    - `stop` (åœæ­¢æ ‡å¿—) åˆå§‹åŒ–ä¸º `false`ã€‚
- **åˆ›å»ºå·¥ä½œçº¿ç¨‹**ï¼š
    - å¾ªç¯ `numThreads` æ¬¡ï¼Œåˆ›å»º `std::thread` å¯¹è±¡ã€‚
    - æ¯ä¸ªçº¿ç¨‹æ‰§è¡Œä¸€ä¸ª lambda å‡½æ•°ï¼Œè¯¥å‡½æ•°æ˜¯å·¥ä½œçº¿ç¨‹çš„æ ¸å¿ƒé€»è¾‘ã€‚
    - `threads.emplace_back(...)`: é«˜æ•ˆåœ°åœ¨ `std::vector<std::thread>` æœ«å°¾æ„é€ çº¿ç¨‹å¯¹è±¡ã€‚

---

#### 3. å·¥ä½œçº¿ç¨‹é€»è¾‘ (åœ¨æ„é€ å‡½æ•°çš„ lambda ä¸­)

- **æ— é™å¾ªç¯**ï¼š`while (true)`ï¼Œçº¿ç¨‹æŒç»­è¿è¡Œç›´åˆ°è¢«æ˜ç¡®åœæ­¢ã€‚
- **ä»»åŠ¡è·å–ä¸åŒæ­¥**ï¼š
    1. `std::unique_lock<std::mutex> lock(mutex)`: è·å–ä¸»äº’æ–¥é” `mutex`ï¼Œä¿æŠ¤ä»»åŠ¡é˜Ÿåˆ— `tasks`ã€åœæ­¢æ ‡å¿— `stop` å’Œæ¡ä»¶å˜é‡ `cv`ã€‚
    2. `cv.wait(lock, [this] { return stop || !tasks.empty(); })`:
        - **ç­‰å¾…æ¡ä»¶**ï¼šå¦‚æœ `stop` ä¸º `false` (æœªåœæ­¢) ä¸” `tasks` ä¸ºç©º (æ— ä»»åŠ¡)ï¼Œåˆ™çº¿ç¨‹é‡Šæ”¾ `lock` å¹¶åœ¨æ­¤é˜»å¡ï¼Œç­‰å¾…è¢«å”¤é†’ã€‚
        - **å”¤é†’åæ£€æŸ¥**ï¼šè¢«å”¤é†’åï¼Œé‡æ–°è·å– `lock` å¹¶å†æ¬¡æ£€æŸ¥æ¡ä»¶ã€‚å¦‚æœæ¡ä»¶æ»¡è¶³ (å³ `stop` ä¸º `true` æˆ– `tasks` éç©º)ï¼Œåˆ™ç»§ç»­æ‰§è¡Œã€‚
    3. **åœæ­¢å¤„ç†**ï¼š`if (stop) { return; }`
        - å¦‚æœçº¿ç¨‹è¢«å”¤é†’æ˜¯å› ä¸º `stop` å˜ä¸º `true` (é€šå¸¸åœ¨ææ„æ—¶)ï¼Œåˆ™çº¿ç¨‹ç›´æ¥è¿”å›ï¼Œç»“æŸæ‰§è¡Œã€‚
    4. **è·å–ä»»åŠ¡**ï¼š
        - `task = tasks.front();`
        - `tasks.pop();`
        - æ­¤æ—¶ `lock` ä»ç„¶æŒæœ‰ï¼Œå®‰å…¨åœ°ä»é˜Ÿåˆ—ä¸­å–å‡ºä»»åŠ¡ã€‚
- **ä»»åŠ¡æ‰§è¡Œ**ï¼š
    - `lock` åœ¨ç¦»å¼€ä½œç”¨åŸŸæ—¶è‡ªåŠ¨é‡Šæ”¾ã€‚
    - `task();`: æ‰§è¡Œå–å‡ºçš„ä»»åŠ¡ã€‚è¿™éƒ¨åˆ†åœ¨é”ä¹‹å¤–æ‰§è¡Œï¼Œå…è®¸å…¶ä»–çº¿ç¨‹è®¿é—®ä»»åŠ¡é˜Ÿåˆ—ã€‚
- **ä»»åŠ¡å®Œæˆåçš„å¤„ç†**ï¼š
    1. `std::unique_lock<std::mutex> lock(mutex)`: å†æ¬¡è·å–ä¸»äº’æ–¥é” `mutex`ã€‚
    2. `taskCount--;`: ä»»åŠ¡å®Œæˆï¼Œé€’å‡è®¡æ•°å™¨ã€‚
    3. `if (taskCount == 0) { cv.notify_all(); }`:
        - å¦‚æœ `taskCount` å‡åˆ° 0ï¼Œæ„å‘³ç€æ‰€æœ‰å·²å…¥é˜Ÿçš„ä»»åŠ¡éƒ½å·²å®Œæˆã€‚
        - å”¤é†’æ‰€æœ‰å¯èƒ½åœ¨ `waitAllTasks` ä¸­ç­‰å¾…çš„çº¿ç¨‹ã€‚

---

#### 4. ä»»åŠ¡å…¥é˜Ÿ `enqueue(Func &&func, Args &&...args)`

- **æ¨¡æ¿åŒ–**ï¼šæ¥å—ä»»æ„å¯è°ƒç”¨å¯¹è±¡ `Func` åŠå…¶å‚æ•° `Args...`ã€‚
- **ä»»åŠ¡è®¡æ•°å¢åŠ **ï¼š
    1. `std::unique_lock<std::mutex> lock(mutexCount)`: è·å– `mutexCount` é”ã€‚
    2. `taskCount++;`: å¢åŠ ä»»åŠ¡è®¡æ•°ã€‚
    3. `lock` è‡ªåŠ¨é‡Šæ”¾ã€‚
- **ä»»åŠ¡å°è£…ä¸å…¥é˜Ÿ**ï¼š
    1. `std::unique_lock<std::mutex> lock(mutex)`: è·å–ä¸»äº’æ–¥é” `mutex`ã€‚
    2. `tasks.emplace([func, args...] { func(args...); });`:
        - åˆ›å»ºä¸€ä¸ªæ–°çš„ lambda å‡½æ•°ï¼Œæ•è· `func` å’Œ `args`ã€‚
        - è¿™ä¸ªæ–°çš„ lambda (ç±»å‹ä¸º `std::function<void()>`) è¢«æ·»åŠ åˆ° `tasks` é˜Ÿåˆ—çš„æœ«å°¾ã€‚
    3. `lock` è‡ªåŠ¨é‡Šæ”¾ã€‚
- **é€šçŸ¥å·¥ä½œçº¿ç¨‹**ï¼š
    - `cv.notify_one();`: å”¤é†’ä¸€ä¸ªï¼ˆå¯èƒ½ï¼‰æ­£åœ¨ç­‰å¾…ä»»åŠ¡çš„å·¥ä½œçº¿ç¨‹ã€‚

---

#### 5. ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ `waitAllTasks()`

- **åŒæ­¥ç­‰å¾…**ï¼š
    1. `std::unique_lock<std::mutex> lock(mutex)`: è·å–ä¸»äº’æ–¥é” `mutex`ã€‚
    2. `cv.wait(lock, [this] { return taskCount == 0; })`:
        - **ç­‰å¾…æ¡ä»¶**ï¼šå¦‚æœ `taskCount` ä¸ä¸º 0ï¼Œåˆ™é‡Šæ”¾ `lock` å¹¶åœ¨æ­¤é˜»å¡ã€‚
        - **å”¤é†’åæ£€æŸ¥**ï¼šå½“è¢«å·¥ä½œçº¿ç¨‹ï¼ˆåœ¨ä»»åŠ¡å®Œæˆåä¸” `taskCount` å˜ä¸º 0 æ—¶ï¼‰é€šè¿‡ `cv.notify_all()` å”¤é†’æ—¶ï¼Œé‡æ–°è·å– `lock` å¹¶æ£€æŸ¥ `taskCount == 0`ã€‚å¦‚æœä¸º `true`ï¼Œåˆ™ç»§ç»­ã€‚
    3. `lock` è‡ªåŠ¨é‡Šæ”¾ï¼Œå‡½æ•°è¿”å›ã€‚

---

#### 6. ææ„å‡½æ•° `~ThreadPool()`

- **è®¾ç½®åœæ­¢æ ‡å¿—**ï¼š
    1. `std::unique_lock<std::mutex> lock(mutex)`: è·å–ä¸»äº’æ–¥é” `mutex`ã€‚
    2. `stop = true;`: è®¾ç½®åœæ­¢æ ‡å¿—ã€‚
    3. `lock` è‡ªåŠ¨é‡Šæ”¾ã€‚
- **å”¤é†’æ‰€æœ‰å·¥ä½œçº¿ç¨‹**ï¼š
    - `cv.notify_all();`: å”¤é†’æ‰€æœ‰å¯èƒ½å› ä»»åŠ¡é˜Ÿåˆ—ä¸ºç©ºè€Œé˜»å¡çš„å·¥ä½œçº¿ç¨‹ã€‚å®ƒä»¬é†’æ¥åä¼šæ£€æŸ¥åˆ° `stop == true` å¹¶é€€å‡ºã€‚
- **ç­‰å¾…çº¿ç¨‹ç»“æŸ**ï¼š
    - `for (auto &thread : threads) { thread.join(); }`: éå†æ‰€æœ‰å·¥ä½œçº¿ç¨‹å¯¹è±¡ï¼Œå¹¶å¯¹æ¯ä¸ªçº¿ç¨‹è°ƒç”¨ `join()`ã€‚è¿™ä¼šé˜»å¡ææ„å‡½æ•°çš„æ‰§è¡Œï¼Œç›´åˆ°ç›¸åº”çš„å·¥ä½œçº¿ç¨‹å®Œå…¨ç»“æŸã€‚ç¡®ä¿èµ„æºè¢«æ­£ç¡®æ¸…ç†ã€‚

---

#### 7. å…³é”®æˆå‘˜å˜é‡

- `size_t taskCount`: è¿½è¸ªå½“å‰é˜Ÿåˆ—ä¸­å’Œæ­£åœ¨æ‰§è¡Œçš„ä»»åŠ¡æ€»æ•°ã€‚ç”¨äº `waitAllTasks`ã€‚
- `bool stop`: æ ‡å¿—ä½ï¼Œé€šçŸ¥å·¥ä½œçº¿ç¨‹åœæ­¢è¿è¡Œã€‚
- `std::mutex mutex`: ä¸»äº’æ–¥é”ï¼Œä¿æŠ¤å¯¹ `tasks` é˜Ÿåˆ—ã€`stop` æ ‡å¿—ä»¥åŠ `cv` çš„è®¿é—®ã€‚ä¹Ÿç”¨äºä¿æŠ¤ `taskCount` çš„é€’å‡æ“ä½œã€‚
- `std::mutex mutexCount`: **ä¸€ä¸ªç‹¬ç«‹çš„äº’æ–¥é”ï¼Œä¸“é—¨ç”¨äºä¿æŠ¤ `taskCount` çš„é€’å¢æ“ä½œã€‚**
- `std::condition_variable cv`: æ¡ä»¶å˜é‡ï¼Œç”¨äºå·¥ä½œçº¿ç¨‹ç­‰å¾…ä»»åŠ¡ï¼Œä»¥åŠ `waitAllTasks` ç­‰å¾…ä»»åŠ¡å®Œæˆã€‚
- `std::vector<std::thread> threads`: å­˜å‚¨æ‰€æœ‰å·¥ä½œçº¿ç¨‹å¯¹è±¡çš„å®¹å™¨ã€‚
- `std::queue<std::function<void()>> tasks`: å­˜å‚¨å¾…æ‰§è¡Œä»»åŠ¡çš„ä»»åŠ¡é˜Ÿåˆ—ã€‚ä»»åŠ¡è¢«å°è£…ä¸º `std::function<void()>`ã€‚

---

#### 8. åŒæ­¥æœºåˆ¶åˆ†æ

- **`mutex` å’Œ `cv`**ï¼šæ„æˆäº†æ ¸å¿ƒçš„ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å‹ã€‚
    - `enqueue` æ˜¯ç”Ÿäº§è€…ï¼Œå°†ä»»åŠ¡æ”¾å…¥ `tasks` é˜Ÿåˆ—ï¼Œå¹¶é€šè¿‡ `cv.notify_one()` å”¤é†’æ¶ˆè´¹è€…ã€‚
    - å·¥ä½œçº¿ç¨‹æ˜¯æ¶ˆè´¹è€…ï¼Œç­‰å¾… `cv`ï¼Œå½“ `tasks` éç©ºæˆ– `stop` ä¸ºçœŸæ—¶è¢«å”¤é†’ï¼Œç„¶åä» `tasks` å–å‡ºä»»åŠ¡ã€‚
- **`mutexCount`**ï¼šå•ç‹¬ç”¨äºä¿æŠ¤ `taskCount` çš„è‡ªå¢æ“ä½œã€‚
    - è¿™æ˜¯ä¸€ä¸ªå€¼å¾—æ³¨æ„çš„è®¾è®¡ç‚¹ã€‚é€šå¸¸ï¼Œå¦‚æœ `taskCount` çš„æ‰€æœ‰ä¿®æ”¹éƒ½ç”±åŒä¸€ä¸ªäº’æ–¥é”ï¼ˆä¾‹å¦‚ä¸» `mutex`ï¼‰ä¿æŠ¤ï¼Œå¯ä»¥ç®€åŒ–è®¾è®¡ã€‚è¿™é‡Œä½¿ç”¨ä¸¤ä¸ªäº’æ–¥é”ï¼Œ`taskCount++` åœ¨ `mutexCount` ä¸‹ï¼Œè€Œ `taskCount--` åœ¨ `mutex` ä¸‹ã€‚è¿™éœ€è¦ä»”ç»†ç¡®ä¿é€»è¾‘æ­£ç¡®æ€§ï¼Œé¿å…æ­»é”ï¼ˆåœ¨æ­¤å®ç°ä¸­ï¼Œç”±äºé”çš„è·å–é¡ºåºå’ŒèŒƒå›´ï¼Œçœ‹èµ·æ¥æ²¡æœ‰ç›´æ¥çš„æ­»é”é£é™©ï¼Œä½†å¢åŠ äº†å¤æ‚æ€§ï¼‰ã€‚
- **`stop` æ ‡å¿—**ï¼šç”¨äºä¼˜é›…åœ°å…³é—­çº¿ç¨‹æ± ã€‚å½“ `stop` ä¸º `true` æ—¶ï¼Œå·¥ä½œçº¿ç¨‹åœ¨ `cv.wait` è¿”å›åä¼šæ£€æµ‹åˆ°æ­¤æ ‡å¿—å¹¶é€€å‡ºã€‚
- **`taskCount` å’Œ `cv` in `waitAllTasks`**ï¼š`waitAllTasks` ä½¿ç”¨ `mutex` å’Œ `cv` æ¥ç­‰å¾… `taskCount` å˜ä¸º0ã€‚å½“æœ€åä¸€ä¸ªä»»åŠ¡å®Œæˆæ—¶ï¼Œæ‰§è¡Œè¯¥ä»»åŠ¡çš„å·¥ä½œçº¿ç¨‹ä¼šé€’å‡ `taskCount` å¹¶é€šè¿‡ `cv.notify_all()` å”¤é†’ `waitAllTasks`ã€‚

#### 9.ä»£ç éƒ¨åˆ†å±•ç¤º
```cpp
// thread pool

class ThreadPool {

public:

ThreadPool(size_t numThreads) : taskCount(0), stop(false) {

for (int i = 0; i < numThreads; i++) {

threads.emplace_back([this] {

while (true) {

std::function<void()> task;

  

{

std::unique_lock<std::mutex> lock(mutex);

cv.wait(lock, [this] { return stop || !tasks.empty(); });

if (stop) {

return;

}

task = tasks.front();

tasks.pop();

}

task();

{

std::unique_lock<std::mutex> lock(mutex);

taskCount--;

if (taskCount == 0) {

cv.notify_all();

}

}

}

});

}

}

  

void waitAllTasks() {

std::unique_lock<std::mutex> lock(mutex);

cv.wait(lock, [this] { return taskCount == 0; });

}

  

template <typename Func, typename... Args>

void enqueue(Func &&func, Args &&...args) {

{

std::unique_lock<std::mutex> lock(mutexCount);

taskCount++;

}

  

{

std::unique_lock<std::mutex> lock(mutex);

tasks.emplace([func, args...] { func(args...); });

}

cv.notify_one();

}

  

~ThreadPool() {

{

std::unique_lock<std::mutex> lock(mutex);

stop = true;

}

cv.notify_all();

for (auto &thread : threads) {

thread.join();

}

}

  

private:

size_t taskCount; // num of tasks

bool stop; // signol of stop

std::mutex mutex;

std::mutex mutexCount;

std::condition_variable cv;

  

std::vector<std::thread> threads;

std::queue<std::function<void()>> tasks;

};
```

æœ¬æ–‡ä½¿ç”¨**Gemini 2.5 pro**ç”Ÿæˆç¬”è®°éƒ¨åˆ†.

ä¸å¾—ä¸è¯´çœŸçš„å¾ˆæ–¹ä¾¿,ç¬”è®°éƒ¨åˆ†æ¸…æ™°åˆæ˜æœ—,~~é€‚åˆæˆ‘è¿™ç§è¶…çº§æ‡’çš„äºº~~.

ğŸ˜‹