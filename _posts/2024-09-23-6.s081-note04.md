---
title: 6.s081-note03
author: Sillycheese
date: 2024/9/11 18:00:27 +0800
categories:
  - MIT6.s081
tags:
  - OS

---

# Trap机制

程序运行是完成用户空间和内核空间的切换

- 程序执行系统调用
- 程序出现了类似page fault、运算时除0的错误
- 一个设备触发了中断使得当前程序运行需要响应内核设备驱动

都会发生这样的切换

这其间用户空间与内核空间的切换通常被称为trap,其中细节对安全隔离与性能来说非常重要。所以，**trap机制要尽可能的简单**

这里有很多寄存器都有特殊的作用，我们之后会看到。比如stack point(堆栈寄存器)。

- 硬件里还有一个寄存器为程序计数器
- 辨明当前mode的标志位，能表明当前是supervisor还是user(运行shell的时候自然是user mode)
- SATP寄存器，指向了page table的物理内存地址
- STVEC寄存器，指向了内核中处理trap的指令的起始位置
- SEPC寄存器，在trap的过程中保存程序计数器的值
- SSRATCH寄存器，详见下面的**uservec函数模块**

这些寄存器表明了执行系统调用时计算机的状态。

可以肯定，在trap的最开始，CPU的所有状态都设置为运行用户代码而不是内核代码。接下来我们预览需要做的操作：

- 首先，保存32个用户寄存器。显然我们需要恢复用户程序的执行，当程序随机的被设备中断所打断，我们希望内核能响应中断，之后用户在无感知的情况下恢复用户代码的执行。这意味着这些寄存器不能被内核所弄乱，却又要被内核代码使用。所以我们要在某处保存这些寄存器
- 程序计数器也需要保存，我们需要在中断的位置继续执行用户程序
- 将mode改为supervisor mode，这样可以使用内核中的特权指令
- SATP现在正指向user page table,而这仅仅包含了用户程序所需要的内存映射和其他映射，并不包括整个内核的内存映射。所以我们需要在运行内核代码前将其指向kernel page table
- 我们需要将堆栈寄存器指向位于内核的一个地址，因为我们需要一个堆栈来调用内核的C函数
- 一旦我们设置好了，并且所有的硬件状态都已经适合在内核中运行，我们需要跳入内核的C代码

运行内核中的C语言代码和平常的一样。之后会讨论内核通过C语言做了什么，但是今天讨论的是如何切换程序执行从用户到内核，这样我们才能运行内核中的代码。

操作系统的一些high-level能过滤掉一些实现选项。其中一个目标安全与隔离：我们不能让用户代码介入这其中的切换过程，否则会破坏安全性。这意味着，trap涉及的硬件与内核机制不能依赖任何用户空间的东西。比如我们不能依赖32个用户寄存器，避免接触到恶意数据，只是将他们保存起来。

另一方面，我们希望trap对于用户是透明的，在执行trap的时候并不会让用户察觉到任何相关事项，也有利于用户写代码。

需要注意，即使用户到内核切换很安全，整个内核的其他部分也必须非常安全，并时刻小心用户代码可能会尝试欺骗它。

当我们mode标志位为切换后，我们获得的权限并非我们想象中的那么多。所以，接下来我们会看看supervisor mode可以控制什么。

其中一件事是，你可以读写控制寄存器了。你可以读写SATP寄存器(指向page table)；STVEC(处理trap的内核指令地址)；SEPC(保存发生trap时的程序计数器);SSCRATCH等等.你可以读写这些寄存器.

另一件可以做的事情,supervisor mode可以使用PTE_U标志位为0的PTE.当其为1时,表明用户代码可以使用这个页表.0则只有supervisor可以用.

除此之外就不能干别的事情了.

需要注意的是,supervisor mode的代码并不能读写任意物理地址,也需要通过page_table来访问内存.如果虚拟地址不在SATP指向的page table中,亦或者PTE_U=1,则无法访问那个地址.即使我们在supervisor mode,我们的操作仍受限于page table设置的虚拟地址.



接下来我们会看一下,进入内核空间时,trap代码的执行流程.

## Trap代码执行流程

为了提前了解接下来的内容,我们会跟踪如何在Shell中调用write系统调用.write通过执行ECALL来执行系统调用,而ECALL会切换到supervisor mode的内核中.在这个过程中,内核中执行的第一个指令是一个由汇编编写的函数,叫做`uservec`.这个函数是内核代码`trampoline.s`文件的一部分.所以执行的低一个代码便是这个`uservec`汇编函数.

之后,在这个函数中,代码执行跳转了由C实现的函数`usertrap`中,这个函数在`trap.c`中.

现在代码运行在C中，所以代码更加容易理解。在`usertrap`这个C函数中，我们执行了一个叫做`syscall`的函数.

这个函数会在一个表单中，根据传入的代表系统调用的数字进行查找，并在内核中执行具体实现了系统调用功能的函数。对于我们来说，这个函数就是`sys_write`.

`sys_write`会将要显示数据输出到console上，当它完成了之后，它会返回给`syscall`函数.

我们现在相当于在ECALL后中断了用户代码的执行,为了用户空间的代码恢复执行,需要做一系列的事.在`syscall`中,会调用一个函数叫做`usertrapret`,它也位于`trap`,这个函数完成了部分方便在C中实现的返回到用户空间的工作.

除此之外,还有些工作只能在汇编语言中完成,存在于`trampoline.s`文件中的`userret`函数中.

最终,在这个汇编函数中会调用机器指令返回到用户空间,并且恢复ECALL之后的用户程序执行.

实际上很多操作系统都提供了一种内存映射文件(Memory-mapped file access)的机制,在这个机制里面通过page table,可以将用户空间的虚拟地址空间,对应到文件内容,这样便可直接通过内存地址读写文件.这个机制的确比直接调用read/write系统调用要快得多.







