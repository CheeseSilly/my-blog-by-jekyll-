---
title: 栈&队列&数组
author: Sillycheese
date: 2025/8/13 19:37:52 +0800
categories:
  - 考研-数据结构
---
# 栈、队列与数组

## 目录
- 1. 栈（Stack）
- 2. 队列（Queue）
- 3. 双端队列与优先队列（Deque & Priority Queue）
- 4. 数组（Array）
- 5. 常见题型与解题模板
- 6. 核心考点速记

---

## 1. 栈（Stack）

### 1.1 定义与特性
- 栈是后进先出（LIFO，Last In First Out）的线性表。
- 典型操作：push(入栈)、pop(出栈)、top/peek(栈顶元素)、isEmpty、size。
- 常见实现：顺序栈（基于数组）与链式栈（基于链表）。

### 1.2 实现要点
- 顺序栈：
  - 需要一个连续的数组/向量来存放元素。
  - 注意上溢（栈满）与下溢（栈空）的边界判断。
  - 动态数组实现更常见，可以在容量不足时扩容。
- 链式栈：
  - 通过单向链表实现，出栈/入栈复杂度都是 O(1)，不需要预设容量。
  - 优点：无容量上限，缺点：指针开销略大。

### 1.3 时间复杂度
- push、pop、top、isEmpty：均为 O(1)（摊销视实现而定，如动态扩容会有偶发的 O(n) 代价，但总体摊销仍是 O(1) 平均）。
  
### 1.4 常见题型与解题思路
- 括号匹配：用栈存放左括号，遇到右括号时与栈顶对对称性检查。
- 表达式求值：中缀表达式转后缀表达式（逆波兰表达式）再求值，或直接用栈实现表达式求值。
- 逆波兰表达式求值：遍历表达式，遇数字入栈，遇运算符弹出需要的操作数进行计算后再入栈。
- 用栈实现队列/双端操作：如用两个栈实现队列，或在特定题型中用栈来回放/反转序列。
- 最小栈（MinStack）：在栈中维护辅助栈记录当前最小值，O(1) 获取最小值。

### 1.5 代码模板（Python）
- 顺序栈（简单版，Python 内置列表即可实现）
```python
class Stack:
    def __init__(self):
        self.data = []

    def push(self, x):
        self.data.append(x)

    def pop(self):
        if not self.data:
            raise IndexError("pop from empty stack")
        return self.data.pop()

    def top(self):
        if not self.data:
            raise IndexError("top from empty stack")
        return self.data[-1]

    def is_empty(self):
        return len(self.data) == 0

    def __len__(self):
        return len(self.data)
```

- 最小栈（MinStack）
```python
class MinStack:
    def __init__(self):
        self.stack = []
        self.min_stack = []

    def push(self, x):
        self.stack.append(x)
        if not self.min_stack or x <= self.min_stack[-1]:
            self.min_stack.append(x)

    def pop(self):
        v = self.stack.pop()
        if v == self.min_stack[-1]:
            self.min_stack.pop()
        return v

    def top(self):
        return self.stack[-1]

    def get_min(self):
        return self.min_stack[-1] if self.min_stack else None
```

- 两个栈实现队列
```python
class StackQueue:
    def __init__(self):
        self.in_stack = []
        self.out_stack = []

    def enqueue(self, x):
        self.in_stack.append(x)

    def dequeue(self):
        if not self.out_stack:
            while self.in_stack:
                self.out_stack.append(self.in_stack.pop())
        if not self.out_stack:
            raise IndexError("dequeue from empty queue")
        return self.out_stack.pop()

    def is_empty(self):
        return not self.in_stack and not self.out_stack
```

---

## 2. 队列（Queue）

### 2.1 定义与特性
- 队列是先进先出（FIFO，First In First Out）的线性表。
- 栈反向的角色：push 变为 enqueue，pop 变为 dequeue。
- 常见实现：顺序队列、循环队列、链式队列、以及更高级的双端队列（Deque）和优先队列（Priority Queue）。

### 2.2 实现要点
- 顺序队列：
  - 用数组维护头尾指针，直观但容易在大量出队后产生“假空”，需要移动/记忆头指针。
- 循环队列（环形缓冲区）：
  - 通过取模运算实现头尾移动，避免数据移动。
  - 边界判定：通常通过头尾指针相遇来判空/判满。
- 链式队列：
  - 通过链表节点实现，入队以尾部插入，出队以头部删除，避免容量限制。
- 双端队列（Deque）：
  - 同时支持队头出/队尾入、队尾出/队头入，灵活性更强。
- 优先队列（Priority Queue）：
  - 根据优先级高低出队，常用堆实现（最大堆或最小堆）。
  
### 2.3 时间复杂度
- 入队/出队：通常 O(1)；具体取决于实现（循环队列和链式队列为 O(1)，数组实现需关注头指针移动）。

### 2.4 常见题型与解题思路
- 广度优先搜索（BFS）：图/树的层级遍历，典型用队列存放待访问节点。
- 队列实现题：用两栈实现队列、用队列实现滑动窗口等。
- 优先队列的应用：最小生成树的某些实现、Dijkstra、A* 等路径算法的核心结构。
- 双端队列在滑动窗口、回文判断等题型中的应用。

### 2.5 代码模板（Python）
- 循环队列（容量 fixed）
```python
class CircularQueue:
    def __init__(self, k):
        self.data = [None] * k
        self.head = 0
        self.tail = 0
        self.size = 0
        self.capacity = k

    def enqueue(self, x):
        if self.is_full():
            raise IndexError("enqueue on full queue")
        self.data[self.tail] = x
        self.tail = (self.tail + 1) % self.capacity
        self.size += 1

    def dequeue(self):
        if self.is_empty():
            raise IndexError("dequeue from empty queue")
        val = self.data[self.head]
        self.data[self.head] = None
        self.head = (self.head + 1) % self.capacity
        self.size -= 1
        return val

    def is_empty(self):
        return self.size == 0

    def is_full(self):
        return self.size == self.capacity
```

- 两栈实现队列（前面已有 MinStack 的思路）
```python
class StackQueue:
    def __init__(self):
        self.in_stack = []
        self.out_stack = []

    def enqueue(self, x):
        self.in_stack.append(x)

    def dequeue(self):
        if not self.out_stack:
            while self.in_stack:
                self.out_stack.append(self.in_stack.pop())
        if not self.out_stack:
            raise IndexError("dequeue from empty queue")
        return self.out_stack.pop()
```

---

## 3. 双端队列与优先队列（Deque & Priority Queue）

### 3.1 双端队列（Deque）
- 支持在两端进行插入和删除的队列。
- 常见题型：滑动窗口中的维护、回文判定、队列的谓词性题型等。
- 实现：可以用 Python 的 collections.deque，或自实现循环数组/链表。

### 3.2 优先队列（Priority Queue）
- 元素带有优先级，出队时总是优先级最高的元素。
- 常见实现：二叉堆（MinHeap/MaxHeap）。
- 应用：Dijkstra/Prim 等算法、任务调度等。

代码模板（Python 内置 heapq 的简单示例）：
```python
import heapq

class MinPriorityQueue:
    def __init__(self):
        self.heap = []

    def push(self, item, priority):
        heapq.heappush(self.heap, (priority, item))

    def pop(self):
        if not self.heap:
            raise IndexError("pop from empty priority queue")
        priority, item = heapq.heappop(self.heap)
        return item

    def is_empty(self):
        return not self.heap
```

---

## 4. 数组（Array）

### 4.1 基本概念
- 静态数组：长度固定，访问常数时间 O(1)，缺点是扩容和删除成本较高。
- 动态数组：容量可扩容，通常通过“容量翻倍”策略实现，平均摊销为 O(1) 访问/写入。

### 4.2 常见操作与复杂度
- 访问/赋值：O(1)
- 插入/删除（在中间位置）：O(n)（需要移动后续元素）
- 数组题型核心常用技巧：双指针、滑动窗口、二分查找、前缀和、差分等。

### 4.3 常见题型与解题思路

#### 4.3.1 双指针法
- 适用场景：有序数组、需要在两端移动的条件等。
- 常见用途：删除重复、两数之和、子序列等。

示例：有序数组去除重复元素（就地去重，返回新长度）
```python
def remove_duplicates(nums):
    if not nums:
        return 0
    i = 0
    for j in range(1, len(nums)):
        if nums[j] != nums[i]:
            i += 1
            nums[i] = nums[j]
    return i + 1
```

#### 4.3.2 两数之和（有序数组）
```python
def two_sum_sorted(nums, target):
    i, j = 0, len(nums) - 1
    while i < j:
        s = nums[i] + nums[j]
        if s == target:
            return (i, j)
        elif s < target:
            i += 1
        else:
            j -= 1
    return None
```

#### 4.3.3 滑动窗口
- 目标：在一个可变窗口内维护和/最大长度/最小值等。
- 常见题型：最长无重复子串、满足条件的子数组长度、最小窗口覆盖等。

示例：最大和不超过 k 的子数组长度（简单版）
```python
def max_subarray_len_under_k(nums, k):
    left = 0
    cur_sum = 0
    max_len = 0
    for right, val in enumerate(nums):
        cur_sum += val
        while cur_sum > k and left <= right:
            cur_sum -= nums[left]
            left += 1
        max_len = max(max_len, right - left + 1)
    return max_len
```

#### 4.3.4 前缀和（Prefix Sum）
- 将数组转换为前缀和数组，快速求任意区间和。
- 常与二分、哈希结合解决子数组等问题。

示例：前缀和数组
```python
def prefix_sums(nums):
    ps = [0]
    for x in nums:
        ps.append(ps[-1] + x)
    return ps
```

#### 4.3.5 差分数组（Difference Array）
- 适用于多次区间加法，最后用前缀和得到结果。
- 典型题型：一段区间内统一修改某值，最后输出数组。

示例：
```python
def difference_array(n, ops):
    diff = [0] * (n + 1)
    for l, r, val in ops:
        diff[l] += val
        if r + 1 < n:
            diff[r + 1] -= val
    ans = [0] * n
    cur = 0
    for i in range(n):
        cur += diff[i]
        ans[i] = cur
    return ans
```

#### 4.3.6 二分查找（Binary Search）
- 在有序数组中定位目标值的下标，或找到满足特定条件的边界。
- 常见变体：lower_bound、upper_bound、find first/last等。

示例：
```python
def binary_search(nums, target):
    lo, hi = 0, len(nums) - 1
    while lo <= hi:
        mid = (lo + hi) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            lo = mid + 1
        else:
            hi = mid - 1
    return -1
```

#### 4.3.7 Kadane 算法（最大子数组和）
```python
def max_subarray_sum(arr):
    if not arr:
        return 0
    max_so_far = curr = arr[0]
    for x in arr[1:]:
        curr = max(x, curr + x)
        max_so_far = max(max_so_far, curr)
    return max_so_far
```

---

## 5. 常见题型与解题模板

### 5.1 栈相关
- 括号匹配：使用栈保存左括号，遇到右括号进行匹配。
- 中缀转后缀表达式（Shunting-yard 算法的一部分思想）+ 逆波兰表达式求值。
- 字符串/表达式处理：如只包含数字、运算符、括号的表达式求值。
- 题型变体：需要在栈中同时维护额外信息（如最小值、计数等）。

模板要点：
- 先掌握基本栈操作及边界判断。
- 对复杂题，先把输入分成能被栈处理的子任务（如括号对齐、分块处理等）。

### 5.2 队列相关
- BFS 实现：用队列按层逐层展开节点，常用于图遍历、树的层序遍历。
- 双端队列在滑动窗口/回文等题中的应用。
- 优先队列在最短路径、调度类题型中的应用。

模板要点：
- 对 BFS 用最小辅助信息（如距离）记忆化。
- 不同题型选用合适的队列实现（单队列、双端队列、优先队列等）。

### 5.3 数组相关
- 双指针、滑动窗口、二分查找、前缀/差分是最核心的工具。
- Kadane、前缀和+哈希、差分数组等组合常用于区间相关题。

实战建议：
- 切题前，先把题意抽象成“需要在序列上进行的线性操作”，并定位到以下工具之一：栈、队列、滑动窗口、二分查找、前缀和、差分、动态规划的基本数组结构。
- 注意边界条件：空数组、单元素、重复元素、负数等情况。
- 记住常用时间复杂度：大多数线性遍历相关为 O(n)，二分查找为 O(log n)，堆/优先队列相关为 O(log n)。

---

## 6. 核心考点速记

- 栈
  - 应用场景：括号匹配、表达式求值、逆波兰表达式、栈模拟（如两栈实现队列）。
  - 数据结构要点：简单实现、统一 API、边界判断。

- 队列
  - 应用场景：BFS、分层遍历、滑动窗口、队列模拟。
  - 数据结构要点：循环队列、双端队列、优先队列的基本应用。

- 数组
  - 基本操作：访问、插入删除在中间偏慢，重点练习头尾/中间的巧妙操作。
  - 双指针/滑动窗口：解决子串、子数组、区间覆盖等问题的主线。
  - 前缀和/差分：快速区间和、批量区间更新。
  - 二分查找：定位、边界类型（左边界/右边界）的辨析。
  - Kadane：最大子数组和、线性时间找出最优区间。
  - 动态规划常与数组配合：常见状态转移需要用数组存放中间结果。

